/*
Plex-API

An Open API Spec for interacting with Plex.tv and Plex Servers

API version: 0.0.3
Contact: Lukeslakemail@gmail.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pms

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// VideoApiService VideoApi service
type VideoApiService service

type ApiGetTimelineRequest struct {
	ctx context.Context
	ApiService *VideoApiService
	ratingKey *interface{}
	key *interface{}
	state *interface{}
	hasMDE *interface{}
	time *interface{}
	duration *interface{}
	context *interface{}
	playQueueItemID *interface{}
	playBackTime *interface{}
	row *interface{}
}

// The rating key of the media item
func (r ApiGetTimelineRequest) RatingKey(ratingKey interface{}) ApiGetTimelineRequest {
	r.ratingKey = &ratingKey
	return r
}

// The key of the media item to get the timeline for
func (r ApiGetTimelineRequest) Key(key interface{}) ApiGetTimelineRequest {
	r.key = &key
	return r
}

// The state of the media item
func (r ApiGetTimelineRequest) State(state interface{}) ApiGetTimelineRequest {
	r.state = &state
	return r
}

// Whether the media item has MDE
func (r ApiGetTimelineRequest) HasMDE(hasMDE interface{}) ApiGetTimelineRequest {
	r.hasMDE = &hasMDE
	return r
}

// The time of the media item
func (r ApiGetTimelineRequest) Time(time interface{}) ApiGetTimelineRequest {
	r.time = &time
	return r
}

// The duration of the media item
func (r ApiGetTimelineRequest) Duration(duration interface{}) ApiGetTimelineRequest {
	r.duration = &duration
	return r
}

// The context of the media item
func (r ApiGetTimelineRequest) Context(context interface{}) ApiGetTimelineRequest {
	r.context = &context
	return r
}

// The play queue item ID of the media item
func (r ApiGetTimelineRequest) PlayQueueItemID(playQueueItemID interface{}) ApiGetTimelineRequest {
	r.playQueueItemID = &playQueueItemID
	return r
}

// The playback time of the media item
func (r ApiGetTimelineRequest) PlayBackTime(playBackTime interface{}) ApiGetTimelineRequest {
	r.playBackTime = &playBackTime
	return r
}

// The row of the media item
func (r ApiGetTimelineRequest) Row(row interface{}) ApiGetTimelineRequest {
	r.row = &row
	return r
}

func (r ApiGetTimelineRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetTimelineExecute(r)
}

/*
GetTimeline Get the timeline for a media item

Get the timeline for a media item

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimelineRequest
*/
func (a *VideoApiService) GetTimeline(ctx context.Context) ApiGetTimelineRequest {
	return ApiGetTimelineRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VideoApiService) GetTimelineExecute(r ApiGetTimelineRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VideoApiService.GetTimeline")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/:/timeline"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ratingKey == nil {
		return nil, reportError("ratingKey is required and must be specified")
	}
	if r.key == nil {
		return nil, reportError("key is required and must be specified")
	}
	if r.state == nil {
		return nil, reportError("state is required and must be specified")
	}
	if r.hasMDE == nil {
		return nil, reportError("hasMDE is required and must be specified")
	}
	if r.time == nil {
		return nil, reportError("time is required and must be specified")
	}
	if r.duration == nil {
		return nil, reportError("duration is required and must be specified")
	}
	if r.context == nil {
		return nil, reportError("context is required and must be specified")
	}
	if r.playQueueItemID == nil {
		return nil, reportError("playQueueItemID is required and must be specified")
	}
	if r.playBackTime == nil {
		return nil, reportError("playBackTime is required and must be specified")
	}
	if r.row == nil {
		return nil, reportError("row is required and must be specified")
	}

	parameterAddToQuery(localVarQueryParams, "ratingKey", r.ratingKey, "")
	parameterAddToQuery(localVarQueryParams, "key", r.key, "")
	parameterAddToQuery(localVarQueryParams, "state", r.state, "")
	parameterAddToQuery(localVarQueryParams, "hasMDE", r.hasMDE, "")
	parameterAddToQuery(localVarQueryParams, "time", r.time, "")
	parameterAddToQuery(localVarQueryParams, "duration", r.duration, "")
	parameterAddToQuery(localVarQueryParams, "context", r.context, "")
	parameterAddToQuery(localVarQueryParams, "playQueueItemID", r.playQueueItemID, "")
	parameterAddToQuery(localVarQueryParams, "playBackTime", r.playBackTime, "")
	parameterAddToQuery(localVarQueryParams, "row", r.row, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accessToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Plex-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetServerCapabilities401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStartUniversalTranscodeRequest struct {
	ctx context.Context
	ApiService *VideoApiService
	hasMDE *interface{}
	path *interface{}
	mediaIndex *interface{}
	partIndex *interface{}
	protocol *interface{}
	fastSeek *interface{}
	directPlay *interface{}
	directStream *interface{}
	subtitleSize *interface{}
	subtites *interface{}
	audioBoost *interface{}
	location *interface{}
	mediaBufferSize *interface{}
	session *interface{}
	addDebugOverlay *interface{}
	autoAdjustQuality *interface{}
}

// Whether the media item has MDE
func (r ApiStartUniversalTranscodeRequest) HasMDE(hasMDE interface{}) ApiStartUniversalTranscodeRequest {
	r.hasMDE = &hasMDE
	return r
}

// The path to the media item to transcode
func (r ApiStartUniversalTranscodeRequest) Path(path interface{}) ApiStartUniversalTranscodeRequest {
	r.path = &path
	return r
}

// The index of the media item to transcode
func (r ApiStartUniversalTranscodeRequest) MediaIndex(mediaIndex interface{}) ApiStartUniversalTranscodeRequest {
	r.mediaIndex = &mediaIndex
	return r
}

// The index of the part to transcode
func (r ApiStartUniversalTranscodeRequest) PartIndex(partIndex interface{}) ApiStartUniversalTranscodeRequest {
	r.partIndex = &partIndex
	return r
}

// The protocol to use for the transcode session
func (r ApiStartUniversalTranscodeRequest) Protocol(protocol interface{}) ApiStartUniversalTranscodeRequest {
	r.protocol = &protocol
	return r
}

// Whether to use fast seek or not
func (r ApiStartUniversalTranscodeRequest) FastSeek(fastSeek interface{}) ApiStartUniversalTranscodeRequest {
	r.fastSeek = &fastSeek
	return r
}

// Whether to use direct play or not
func (r ApiStartUniversalTranscodeRequest) DirectPlay(directPlay interface{}) ApiStartUniversalTranscodeRequest {
	r.directPlay = &directPlay
	return r
}

// Whether to use direct stream or not
func (r ApiStartUniversalTranscodeRequest) DirectStream(directStream interface{}) ApiStartUniversalTranscodeRequest {
	r.directStream = &directStream
	return r
}

// The size of the subtitles
func (r ApiStartUniversalTranscodeRequest) SubtitleSize(subtitleSize interface{}) ApiStartUniversalTranscodeRequest {
	r.subtitleSize = &subtitleSize
	return r
}

// The subtitles
func (r ApiStartUniversalTranscodeRequest) Subtites(subtites interface{}) ApiStartUniversalTranscodeRequest {
	r.subtites = &subtites
	return r
}

// The audio boost
func (r ApiStartUniversalTranscodeRequest) AudioBoost(audioBoost interface{}) ApiStartUniversalTranscodeRequest {
	r.audioBoost = &audioBoost
	return r
}

// The location of the transcode session
func (r ApiStartUniversalTranscodeRequest) Location(location interface{}) ApiStartUniversalTranscodeRequest {
	r.location = &location
	return r
}

// The size of the media buffer
func (r ApiStartUniversalTranscodeRequest) MediaBufferSize(mediaBufferSize interface{}) ApiStartUniversalTranscodeRequest {
	r.mediaBufferSize = &mediaBufferSize
	return r
}

// The session ID
func (r ApiStartUniversalTranscodeRequest) Session(session interface{}) ApiStartUniversalTranscodeRequest {
	r.session = &session
	return r
}

// Whether to add a debug overlay or not
func (r ApiStartUniversalTranscodeRequest) AddDebugOverlay(addDebugOverlay interface{}) ApiStartUniversalTranscodeRequest {
	r.addDebugOverlay = &addDebugOverlay
	return r
}

// Whether to auto adjust quality or not
func (r ApiStartUniversalTranscodeRequest) AutoAdjustQuality(autoAdjustQuality interface{}) ApiStartUniversalTranscodeRequest {
	r.autoAdjustQuality = &autoAdjustQuality
	return r
}

func (r ApiStartUniversalTranscodeRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartUniversalTranscodeExecute(r)
}

/*
StartUniversalTranscode Start Universal Transcode

Begin a Universal Transcode Session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiStartUniversalTranscodeRequest
*/
func (a *VideoApiService) StartUniversalTranscode(ctx context.Context) ApiStartUniversalTranscodeRequest {
	return ApiStartUniversalTranscodeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *VideoApiService) StartUniversalTranscodeExecute(r ApiStartUniversalTranscodeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VideoApiService.StartUniversalTranscode")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/video/:/transcode/universal/start.mpd"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hasMDE == nil {
		return nil, reportError("hasMDE is required and must be specified")
	}
	if r.path == nil {
		return nil, reportError("path is required and must be specified")
	}
	if r.mediaIndex == nil {
		return nil, reportError("mediaIndex is required and must be specified")
	}
	if r.partIndex == nil {
		return nil, reportError("partIndex is required and must be specified")
	}
	if r.protocol == nil {
		return nil, reportError("protocol is required and must be specified")
	}

	parameterAddToQuery(localVarQueryParams, "hasMDE", r.hasMDE, "")
	parameterAddToQuery(localVarQueryParams, "path", r.path, "")
	parameterAddToQuery(localVarQueryParams, "mediaIndex", r.mediaIndex, "")
	parameterAddToQuery(localVarQueryParams, "partIndex", r.partIndex, "")
	parameterAddToQuery(localVarQueryParams, "protocol", r.protocol, "")
	if r.fastSeek != nil {
		parameterAddToQuery(localVarQueryParams, "fastSeek", r.fastSeek, "")
	}
	if r.directPlay != nil {
		parameterAddToQuery(localVarQueryParams, "directPlay", r.directPlay, "")
	}
	if r.directStream != nil {
		parameterAddToQuery(localVarQueryParams, "directStream", r.directStream, "")
	}
	if r.subtitleSize != nil {
		parameterAddToQuery(localVarQueryParams, "subtitleSize", r.subtitleSize, "")
	}
	if r.subtites != nil {
		parameterAddToQuery(localVarQueryParams, "subtites", r.subtites, "")
	}
	if r.audioBoost != nil {
		parameterAddToQuery(localVarQueryParams, "audioBoost", r.audioBoost, "")
	}
	if r.location != nil {
		parameterAddToQuery(localVarQueryParams, "location", r.location, "")
	}
	if r.mediaBufferSize != nil {
		parameterAddToQuery(localVarQueryParams, "mediaBufferSize", r.mediaBufferSize, "")
	}
	if r.session != nil {
		parameterAddToQuery(localVarQueryParams, "session", r.session, "")
	}
	if r.addDebugOverlay != nil {
		parameterAddToQuery(localVarQueryParams, "addDebugOverlay", r.addDebugOverlay, "")
	}
	if r.autoAdjustQuality != nil {
		parameterAddToQuery(localVarQueryParams, "autoAdjustQuality", r.autoAdjustQuality, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["accessToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Plex-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetServerCapabilities401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
